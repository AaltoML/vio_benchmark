#ifndef VIO_API_HPP
#define VIO_API_HPP

#include <memory>
#include <vector>
#include <array>
#include <string>

#include "types.hpp"

namespace accelerated { struct Image; }
namespace cv { class Mat; }

namespace api {

struct Visualization;

struct CameraParameters {
    // Negative values denote uninitialized.
    double focalLengthX = -1.0;
    double focalLengthY = -1.0;
    double principalPointX = -1.0;
    double principalPointY = -1.0;

    CameraParameters() {}
    CameraParameters(double focalLength) {
        focalLengthX = focalLength;
        focalLengthY = focalLength;
    }

    // TODO: distortion coefs etc.
};

class VioApi {
public:
    virtual ~VioApi() = default;

    enum class ColorFormat {
        GRAY,
        RGB,
        RGBA,
        RGBA_EXTERNAL_OES
    };

    struct VioOutput {
        /**
         * Current tracking status
         */
        TrackingStatus status;

        /**
         * The current pose, with the timestamp in the clock used for inputted
         * ensor data and camera frames.
         */
        Pose pose;

        /**
         * Velocity vector (xyz) in m/s in the coordinate system used by pose.
         */
        Vector3d velocity;

        /**
         * Uncertainty of the current position as a 3x3 covariance matrix
         */
        Matrix3d positionCovariance;

        /**
         * List of poses, where the first element corresponds to
         * the value returned by getPose and the following (zero or more)
         * values are the recent smoothed historical positions
         */
        std::vector<Pose> poseTrail;

        /**
         * Point cloud (list of FeaturePoints) that correspond to
         * features currently seen by the camera.
         */
        std::vector<FeaturePoint> pointCloud;

        /**
         * Status text, free form output that can be used to describe VIO status
         */
        std::string statusText;

        /**
         * The input frame tag. This is the value given in addFrame... methods
         */
        int tag;

        virtual ~VioOutput() = default;
    };

    // Output API, called when ever there is a new output available
    std::function<void(std::shared_ptr<const VioOutput>)> onOutput;

    // If set, will receive the JSONL outputs which contain all non-image inputs,
    // certain outputs, extra debug data added with addDebugData, and possilby
    // other debug data generated by the algorithm
    std::function<void(const std::string &)> onJsonLogLine;

    // Thread-safe input API. These methods can be called from any thread

    virtual void addAcc(double t, const Vector3d &sample) = 0;

    virtual void addGyro(double t, const Vector3d &sample) = 0;

    // The data must be in JSON format. (optional feature): certain fields could
    // have special meanings, for example "time" in the root could override the
    // timestamp, which all JSONL fields in the output log have
    virtual void addAuxiliaryJsonData(const std::string &auxiliaryJsonData) = 0;

    virtual void addFrameMono(
        double t, const CameraParameters &cam,
        int w, int h, std::uint8_t *data, // TODO: const?
        ColorFormat colorFormat, int tag) = 0;

    virtual void addFrameStereo(
        double t, const CameraParameters &cam0, const CameraParameters &cam1,
        int w, int h, std::uint8_t *data0, std::uint8_t *data1, // TODO: const?
        ColorFormat colorFormat, int tag) = 0;

    // OpenGL GPU extension. Cannot be used simultaneously with CPU-based
    // "addFrameX" variants (aborts if attempted).

    // If set, called whenever there are new items that should be processed
    // in the OpenGL thread by calling "processOpenGl". Here "OpenGL thread"
    // means any thread which has an OpenGl context, which is active  when
    // these methods are used.
    std::function<void()> onOpenGlWork;

    // These methods must be called from the OpenGL thread. The texture ID
    // must be valid in this OpenGL context
    virtual void addFrameMonoOpenGl(
        double t, const CameraParameters &cam,
        int w, int h, int externalOesTextureId,
        ColorFormat colorFormat, int tag) = 0;

    virtual void addFrameStereoOpenGl(
        double t, const CameraParameters &cam0, const CameraParameters &cam1,
        int w, int h, int externalOesTextureId0, int externalOesTextureId1,
        ColorFormat colorFormat, int tag) = 0;

    // Process pending OpenGL operations, if any. If OpenGL inputs are used,
    // must be called
    virtual void processOpenGl() = 0;

    // Must be called from the OpenGL thread and return before the main
    // destructor is called (if OpenGL inputs have been used). All created
    // "visualizations" must also be deconstructed before calling this
    virtual void destroyOpenGl() = 0;

    // This could also be detached from the main API and put into its own file
    // so that visualization can only access Output but not any algorithm
    // internals.
    virtual std::shared_ptr<Visualization> createVisualization(const std::string &type) = 0;
};

// Visualizations
struct Visualization {
    /**
     * If supported creates a default image with correct dimensions and type supported by Visualization.
     */
    virtual std::unique_ptr<accelerated::Image> createDefaultRenderTarget() = 0;

    virtual void update(std::shared_ptr<const VioApi::VioOutput> output) = 0;
    virtual void render(cv::Mat &target) = 0;
    virtual void render(accelerated::Image &target) = 0;
    virtual void render() = 0;

    // Check if the visualization is ready to be rendered
    virtual bool ready() const = 0;

    virtual ~Visualization() = default;
};

} // namespace api

#endif // VIO_API_HPP
